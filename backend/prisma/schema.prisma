// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

// ================================
// üè¢ MULTI-TENANT SaaS MODEL
// ================================

// Empresas/Organizations (Tenants)
model Company {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique // para subdomain ou custom domain
  domain      String?  @unique // custom domain opcional
  plan        String   @default("FREE") // FREE, BASIC, PRO, ENTERPRISE
  isActive    Boolean  @default(true)
  maxUsers    Int      @default(5)
  maxSessions Int      @default(3)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relacionamentos
  companyUsers        CompanyUser[]
  messagingSessions   MessagingSession[]
  chatFlows           ChatFlow[]
  messages            Message[]
  contacts            Contact[]
  tickets             Ticket[]
  subscriptions       Subscription[]
  invitations         CompanyInvitation[]
  businessHours       BusinessHours[]
  holidays            Holiday[]
  contactFlowStates   ContactFlowState[] // NOVO: Estados de fluxo dos contatos

  @@map("companies")
}

// Sistema de Roles
model Role {
  id          String   @id @default(cuid())
  name        String   @unique // SUPER_ADMIN, COMPANY_OWNER, COMPANY_ADMIN, COMPANY_MEMBER, COMPANY_VIEWER
  description String?
  permissions String   @db.NText // JSON array com permiss√µes espec√≠ficas
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relacionamentos
  companyUsers CompanyUser[]

  @@map("roles")
}

// Usu√°rios (podem pertencer a m√∫ltiplas empresas)
model User {
  id           String   @id @default(cuid())
  email        String   @unique
  password     String   // bcrypt hash
  name         String
  avatar       String?
  isActive     Boolean  @default(true)
  isFirstLogin Boolean  @default(true) // For√ßa mudan√ßa de senha no primeiro login
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relacionamentos
  companyUsers    CompanyUser[]
  refreshTokens   RefreshToken[]
  sessions        Session[]
  sentInvitations CompanyInvitation[] @relation("InvitedBy")
  assignedTickets Ticket[] @relation("AssignedAgent")

  @@map("users")
}

// Relacionamento Many-to-Many entre User e Company
model CompanyUser {
  id        String      @id @default(cuid())
  userId    String
  companyId String
  roleId    String      // Relacionamento com Role
  isActive  Boolean     @default(true)
  joinedAt  DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  // Relacionamentos
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  role    Role    @relation(fields: [roleId], references: [id])

  @@unique([userId, companyId])
  @@map("company_users")
}

// ================================
// üîê AUTENTICA√á√ÉO E SEGURAN√áA
// ================================

// Refresh Tokens para autentica√ß√£o segura
model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  isRevoked Boolean  @default(false)

  // Relacionamentos
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

// Sess√µes de usu√°rio (para controle de sess√µes ativas)
model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  userAgent String?
  ipAddress String?
  expiresAt DateTime
  createdAt DateTime @default(now())
  lastUsed  DateTime @default(now())

  // Relacionamentos
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

// Convites para empresas
model CompanyInvitation {
  id         String           @id @default(cuid())
  email      String
  companyId  String
  roleId     String           // Relacionamento com Role
  token      String           @unique
  status     String           @default("PENDING") // PENDING, ACCEPTED, EXPIRED, REVOKED
  invitedBy  String
  expiresAt  DateTime
  createdAt  DateTime         @default(now())
  acceptedAt DateTime?

  // Relacionamentos
  company     Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  invitedUser User    @relation("InvitedBy", fields: [invitedBy], references: [id])

  @@unique([email, companyId])
  @@map("company_invitations")
}

// ================================
// üé´ SISTEMA DE TICKETS
// ================================

// Tickets de Atendimento
model Ticket {
  id                String    @id @default(cuid())
  companyId         String
  messagingSessionId String
  contactId         String
  assignedAgentId   String?   // Atendente respons√°vel
  title             String?   // T√≠tulo do ticket
  description       String?   @db.NText
  status            String    @default("OPEN") // OPEN, IN_PROGRESS, WAITING_CUSTOMER, RESOLVED, CLOSED
  priority          String    @default("MEDIUM") // LOW, MEDIUM, HIGH, URGENT
  category          String?   // Categoria do problema
  source            String    @default("MESSAGING") // MESSAGING, EMAIL, CHAT, PHONE, WEB
  firstResponseAt   DateTime?
  resolvedAt        DateTime?
  closedAt          DateTime?
  tags              String?   @db.NText // Tags como JSON array
  metadata          String?   @db.NText // Metadados extras
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  lastMessageAt      DateTime?
  autoCloseAt      DateTime?

  // Relacionamentos
  company           Company           @relation(fields: [companyId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  messagingSession  MessagingSession  @relation(fields: [messagingSessionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  contact           Contact           @relation(fields: [contactId], references: [id], onDelete: Cascade)
  assignedAgent     User?             @relation("AssignedAgent", fields: [assignedAgentId], references: [id])
  messages          Message[]
  history         TicketHistory[]

  @@map("tickets")
}

// Hist√≥rico de mudan√ßas nos tickets
model TicketHistory {
  id         String   @id @default(cuid())
  ticketId   String
  userId     String?  // Quem fez a mudan√ßa
  action     String   // CREATED, ASSIGNED, STATUS_CHANGED, PRIORITY_CHANGED, CLOSED, etc.
  fromValue  String?  // Valor anterior
  toValue    String?  // Novo valor
  comment    String?  @db.NText
  createdAt  DateTime @default(now())

  // Relacionamentos
  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("ticket_history")
}

// ================================
// ü§ñ MESSAGING & CHATBOT
// ================================

// Sess√µes de Mensageria (WhatsApp, Telegram, Instagram, etc.)
model MessagingSession {
  id          String              @id @default(cuid())
  companyId   String
  name        String
  platform    String              @default("WHATSAPP") // WHATSAPP, TELEGRAM, INSTAGRAM, FACEBOOK_MESSENGER, SMS, etc.
  phoneNumber String?             // Para WhatsApp e SMS
  username    String?             // Para Telegram, Instagram, etc.
  platformId  String?             // ID espec√≠fico da plataforma (chat_id do Telegram, etc.)
  qrCode      String?             // Para WhatsApp (quando necess√°rio)
  accessToken String?             // Para plataformas que usam tokens (Instagram, Facebook)
  status      String              @default("DISCONNECTED") // CONNECTED, DISCONNECTED, CONNECTING, ERROR
  isActive    Boolean             @default(true)
  lastSeen    DateTime?
  config      String?             @db.NText // JSON com configura√ß√µes espec√≠ficas da plataforma
  webhookUrl  String?             // URL do webhook para receber mensagens
  metadata    String?             @db.NText // Metadados extras da plataforma
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  // Relacionamentos
  company           Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  messages          Message[]
  contacts          Contact[]
  tickets           Ticket[]
  contactFlowStates ContactFlowState[]

  @@unique([companyId, platform, phoneNumber]) // Evitar duplicatas por empresa/plataforma/n√∫mero
  @@unique([companyId, platform, username])    // Evitar duplicatas por empresa/plataforma/username
  @@map("messaging_sessions")
}

// Fluxos de Chat (React Flow)
model ChatFlow {
  id          String    @id @default(cuid())
  companyId   String
  name        String
  description String?
  nodes       String    @db.NText // React Flow nodes como JSON string
  edges       String    @db.NText // React Flow edges como JSON string
  triggers    String    @db.NText // array de triggers/palavras-chave como JSON string
  isActive    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relacionamentos
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  contactFlowStates ContactFlowState[] // NOVO: Estados de fluxo dos contatos

  @@map("chat_flows")
}

// üî• NOVO: Controle de Estado do Fluxo por Contato
model ContactFlowState {
  id                 String    @id @default(cuid())
  companyId          String
  messagingSessionId String
  contactId          String
  chatFlowId         String
  currentNodeId      String    // N√≥ atual onde o contato est√°
  isActive           Boolean   @default(true)
  variables          String?   @db.NText // Vari√°veis coletadas durante o fluxo (JSON)
  awaitingInput      Boolean   @default(false) // Se est√° aguardando resposta do usu√°rio
  inputType          String?   // Tipo de input esperado: "text", "button", "condition", etc.
  timeoutAt          DateTime? // Quando expira o estado atual (para timeouts)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relacionamentos
  company          Company          @relation(fields: [companyId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  messagingSession MessagingSession @relation(fields: [messagingSessionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  contact          Contact          @relation(fields: [contactId], references: [id], onDelete: Cascade)
  chatFlow         ChatFlow         @relation(fields: [chatFlowId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  flowHistory      ContactFlowHistory[]

  // Um contato s√≥ pode ter um estado ativo por sess√£o
  @@unique([companyId, messagingSessionId, contactId, isActive])
  @@map("contact_flow_states")
}

// üìú NOVO: Hist√≥rico de Execu√ß√£o do Fluxo
model ContactFlowHistory {
  id                 String   @id @default(cuid())
  contactFlowStateId String
  nodeId             String   // N√≥ que foi executado
  nodeType           String   // Tipo do n√≥: "message", "condition", "delay", etc.
  action             String   // ENTERED, EXECUTED, CONDITION_MET, TIMEOUT, ERROR
  input              String?  @db.NText // Input do usu√°rio que causou a a√ß√£o
  output             String?  @db.NText // Output/resposta gerada
  conditionResult    String?  // Resultado da condi√ß√£o (se aplic√°vel)
  variables          String?  @db.NText // Estado das vari√°veis no momento
  executionTime      Int?     // Tempo de execu√ß√£o em ms
  createdAt          DateTime @default(now())

  // Relacionamentos
  contactFlowState ContactFlowState @relation(fields: [contactFlowStateId], references: [id], onDelete: Cascade)

  @@map("contact_flow_history")
}

// Contatos (com novas rela√ß√µes)
model Contact {
  id                 String    @id @default(cuid())
  companyId          String
  messagingSessionId String
  phoneNumber        String
  name               String?
  avatar             String?
  lastMessage        String?
  lastMessageAt      DateTime?
  isBlocked          Boolean   @default(false)
  tags               String?   @db.NText // array de tags como JSON string
  customFields       String?   @db.NText // campos customizados como JSON string
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relacionamentos
  company          Company          @relation(fields: [companyId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  messagingSession MessagingSession @relation(fields: [messagingSessionId], references: [id], onDelete: Cascade)
  messages         Message[]
  tickets          Ticket[]
  flowStates       ContactFlowState[] // NOVO: Estados de fluxo

  @@unique([companyId, phoneNumber])
  @@map("contacts")
}

// Mensagens
model Message {
  id                 String          @id @default(cuid())
  companyId          String
  messagingSessionId String
  contactId          String
  ticketId           String?         // Mensagem pode estar relacionada a um ticket
  content            String          @db.NText
  type               String          @default("TEXT") // TEXT, IMAGE, AUDIO, VIDEO, DOCUMENT, STICKER, LOCATION
  direction          String          // INCOMING, OUTGOING
  mediaUrl           String?
  isRead             Boolean         @default(false)
  isFromBot          Boolean         @default(false) // Se a mensagem veio do chatbot
  metadata           String?         @db.NText // metadados adicionais como JSON string
  createdAt          DateTime        @default(now())

  // Relacionamentos
  company          Company          @relation(fields: [companyId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  messagingSession MessagingSession @relation(fields: [messagingSessionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  contact          Contact          @relation(fields: [contactId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  ticket           Ticket?          @relation(fields: [ticketId], references: [id], onDelete: SetNull)

  @@map("messages")
}

// ================================
// üí≥ BILLING & SUBSCRIPTIONS
// ================================

model Subscription {
  id                String           @id @default(cuid())
  companyId         String
  plan              String           // FREE, BASIC, PRO, ENTERPRISE
  status            String           // ACTIVE, CANCELED, INCOMPLETE, INCOMPLETE_EXPIRED, PAST_DUE, TRIALING, UNPAID
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  cancelAtPeriodEnd Boolean          @default(false)
  stripeSubscriptionId String?       @unique
  stripePriceId     String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relacionamentos
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

// ================================
// üïê HOR√ÅRIOS DE FUNCIONAMENTO
// ================================

// Hor√°rios de funcionamento da empresa
model BusinessHours {
  id          String   @id @default(cuid())
  companyId   String
  dayOfWeek   Int      // 0 = Domingo, 1 = Segunda, ..., 6 = S√°bado
  isActive    Boolean  @default(true) // Se trabalha neste dia
  startTime   String   // Formato: "08:00"
  endTime     String   // Formato: "17:00"
  breakStart  String?  // Hor√°rio de almo√ßo in√≠cio: "12:00"
  breakEnd    String?  // Hor√°rio de almo√ßo fim: "13:00"
  timezone    String   @default("America/Sao_Paulo") // Timezone da empresa
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relacionamentos
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, dayOfWeek])
  @@map("business_hours")
}

// Feriados e dias especiais
model Holiday {
  id          String   @id @default(cuid())
  companyId   String
  name        String   // Nome do feriado: "Natal", "Black Friday"
  date        DateTime // Data espec√≠fica
  type        String   @default("HOLIDAY") // HOLIDAY, SPECIAL_HOURS, CLOSED
  startTime   String?  // Para dias com hor√°rio especial
  endTime     String?  // Para dias com hor√°rio especial
  isRecurring Boolean  @default(false) // Se repete anualmente
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relacionamentos
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("holidays")
}

// ================================
